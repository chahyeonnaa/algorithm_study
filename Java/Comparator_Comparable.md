Comparator와 Comparable
========================
* Comparator와 Comparable은 모두 인터페이스이다. 이것들을 사용하고자 할 때는, 인터페이스 내에 선언된 메소드를 '반드시 구현'해야한다.  
  * *interface : 함수의 껍데기만 있는 클래스(필수요소들이 선언만 되어있음)(추상메소드) / class : 필수 요소들을 구체적으로 구현*
* Comparator는 **compare(T o1, T o2) 메소드**를 반드시 오버라이딩(재정의)해야하고, Comparable는 **compareTo(T o) 메소드**를 재정의 해야한다.  
* Comparator와 Comparable는 **객체비교**를 위해 만들어졌다. *(기본 자료형들은 부등호로 쉽게 비교가 가능하지만, 사용자 정의 객체는 비교기준을 사용자가 따로 정의해주어야한다.*  


차이점
-----------
* Comparable은 **자기 자신과 매개변수 객체를 비교**하는 것(자기 자신과 파라미터로 들어오는 객체를 비교)  
* Comparator는 **두 매개변수 객체를 비교**하는 것(자기 자신의 상태가 어떻던 상관없이 파라미터로 들어오는 두 객체를 비교하는 것)  
-> ***즉, 본질적으로 비교한다는 것 자체는 같지만, 비교 대상이 다르다.***


Comparable과 Comparator의 정렬 관계
-----------------------------------
*Java에서의 정렬은 특별한 정의가 되어있지 않는 한 '오름차순'을 기준*  
*선행 원소는 값이 작다고 가정하고, 후행 원소는 값이 크다고 가정*
* 객체를 비교하기 위해 Comparable 또는 Comparator을 쓴다는 것은 곧 사용자가 정의한 기준을 토대로 비교를 하여 양수, 0, 음수 중 하나가 반환된다는 의미  
  * compare 혹은 compareTo를 사용하여 객체를 비교 할 경우 음수가 나오면 두 원소의 위치를 바꾸지 않는다는 뜻(양수가 나오면 두 원소의 위치를 바꾼다)  
  -> 앞에있는 원소가 뒤에있는 원소보다 작기 때문에 오름차순 정렬에 위배되지 않음
```
기본적으로 compare 메소드는 3가지 리턴 값에 의해 위치를 바꿀지 결정하게 된다. 3가지 리턴 값이라 하면 다음과 같다.

  - 양의 정수 : 위치 바꿈 
  - 0 : 위치 바꾸지 않음
  - 음의 정수 : 위치 바꾸지 않음
```  
* 내림차순 정렬을 하고 싶으면 compare함수에서 리턴값을 반대로 해주면 된다.
    * 두 값의 차가 양수가 된다면 이를 음수로 바꿔 반환해주고, 만약 음수가 된다면 그 값을 양수로 바꾸어 반환해주면 된다.  


* 카운팅 정렬을 제외하고 웬만한 정렬은 비교를 기반으로 하기 때문에 Comparator 혹은 Comparable를 사용한다.  
* Arrays.sort()에는 단순히 배열만 파라미터로 받는 것이 아니라 Comparator 또한 파라미터로 받기도 한다.  
  -> 배열과 익명객체를 함께 넘겨주어 정렬도 가능하다.  
```
       Comparator<int[]>comp=new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                if(o1[1]==o2[1])
                    return o1[0]-o2[0];
                else
                    return o1[1]-o2[1];
            }
        };

        Arrays.sort(arr,comp);
```
```
        // 이렇게도 가능하다.
          Arrays.sort(arr, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                if(o1[1]==o2[1])
                    return o1[0]-o2[0];
                else
                    return o1[1]-o2[1];
            }
        });
```
